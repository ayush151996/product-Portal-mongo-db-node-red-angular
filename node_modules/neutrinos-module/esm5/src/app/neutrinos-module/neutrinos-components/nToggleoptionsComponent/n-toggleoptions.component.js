import * as tslib_1 from "tslib";
// import { MatSnackBar } from '@angular/material';
import { Component, Input, EventEmitter, Output } from '@angular/core';
var NToggleoptionsComponent = /** @class */ (function () {
    function NToggleoptionsComponent() {
        // options = {icon: 'home', value: 'home', disabled: false, 'checked': false}
        this.toggleOptions = [];
        this.align = 'horizontal';
        this.indexChange = new EventEmitter();
        this.valueChange = new EventEmitter();
    }
    // constructor(private snackbar: MatSnackBar) {
    // }
    NToggleoptionsComponent.prototype.ngOnInit = function () {
        if (this.checkNumber(this.checkedIndex)) {
            this.checkedIndex = Number(this.checkedIndex);
        }
        if (this.checkNumber(this.disabledIndex)) {
            this.disabledIndex = Number(this.disabledIndex);
        }
    };
    NToggleoptionsComponent.prototype.ngOnChanges = function (changes) {
        if (changes['checkedIndex'] && this.checkNumber(this.checkedIndex)) {
            this.checkedIndex = Number(this.checkedIndex);
        }
        else if (changes['disabledIndex'] && this.checkNumber(this.disabledIndex)) {
            this.disabledIndex = Number(this.disabledIndex);
        }
    };
    NToggleoptionsComponent.prototype.optionClicked = function (index) {
        if (this.toggleOptions && this.toggleOptions.length > 0) {
            this.indexChange.emit(index);
            if (this.toggleOptions[index] && this.toggleOptions[index].value) {
                this.valueChange.emit(this.toggleOptions[index].value);
            }
            else {
                // this.snackbar.open('Invalid toggle button value', 'OK');
            }
        }
        else {
            // this.snackbar.open('Invalid toggle options', 'OK');
        }
    };
    NToggleoptionsComponent.prototype.checkNumber = function (number) {
        if (number !== undefined && number !== null) {
            return Number.isNaN(Number(number));
        }
        return false;
    };
    tslib_1.__decorate([
        Input('toggleOptions'),
        tslib_1.__metadata("design:type", Object)
    ], NToggleoptionsComponent.prototype, "toggleOptions", void 0);
    tslib_1.__decorate([
        Input('align'),
        tslib_1.__metadata("design:type", Object)
    ], NToggleoptionsComponent.prototype, "align", void 0);
    tslib_1.__decorate([
        Input('disabledIndex'),
        tslib_1.__metadata("design:type", Object)
    ], NToggleoptionsComponent.prototype, "disabledIndex", void 0);
    tslib_1.__decorate([
        Input('checkedIndex'),
        tslib_1.__metadata("design:type", Object)
    ], NToggleoptionsComponent.prototype, "checkedIndex", void 0);
    tslib_1.__decorate([
        Input('value'),
        tslib_1.__metadata("design:type", String)
    ], NToggleoptionsComponent.prototype, "value", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], NToggleoptionsComponent.prototype, "indexChange", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], NToggleoptionsComponent.prototype, "valueChange", void 0);
    NToggleoptionsComponent = tslib_1.__decorate([
        Component({
            selector: 'n-toggleoptions',
            template: "<mat-button-toggle-group #group=\"matButtonToggleGroup\" [vertical]=\"align == 'vertical'? true: false\" [value]=\"value\">\n    <mat-button-toggle *ngFor=\"let option of toggleOptions; let i = index;\" [value]=\"option.value\" [disabled]=\"option.disabled || disabledIndex == i\" [checked]=\"option.checked || checkedIndex == i\" (click)=\"optionClicked(i)\" fxLayoutAlign=\"center center\">\n        <mat-icon *ngIf=\"option.icon\">{{option.icon}}</mat-icon>\n        <span *ngIf=\"!option.icon && option.value\">{{option.value}}</span>\n    </mat-button-toggle>\n</mat-button-toggle-group>"
        })
    ], NToggleoptionsComponent);
    return NToggleoptionsComponent;
}());
export { NToggleoptionsComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibi10b2dnbGVvcHRpb25zLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25ldXRyaW5vcy1tb2R1bGUvIiwic291cmNlcyI6WyJzcmMvYXBwL25ldXRyaW5vcy1tb2R1bGUvbmV1dHJpbm9zLWNvbXBvbmVudHMvblRvZ2dsZW9wdGlvbnNDb21wb25lbnQvbi10b2dnbGVvcHRpb25zLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsbURBQW1EO0FBQ25ELE9BQU8sRUFBRSxTQUFTLEVBQW9DLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFBO0FBT3hHO0lBTEE7UUFNSSw2RUFBNkU7UUFDckQsa0JBQWEsR0FBRyxFQUFFLENBQUM7UUFDM0IsVUFBSyxHQUFHLFlBQVksQ0FBQztRQUkzQixnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDakMsZ0JBQVcsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBMEMvQyxDQUFDO0lBekNHLCtDQUErQztJQUMvQyxJQUFJO0lBRUosMENBQVEsR0FBUjtRQUNJLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDckMsSUFBSSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUN0QyxJQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDbkQ7SUFFTCxDQUFDO0lBRUQsNkNBQVcsR0FBWCxVQUFZLE9BQXNCO1FBQzlCLElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQ2hFLElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUNqRDthQUFNLElBQUksT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQ3pFLElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNuRDtJQUNMLENBQUM7SUFFRCwrQ0FBYSxHQUFiLFVBQWMsS0FBSztRQUNmLElBQUksSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDN0IsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFO2dCQUM5RCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzFEO2lCQUFNO2dCQUNILDJEQUEyRDthQUM5RDtTQUNKO2FBQU07WUFDSCxzREFBc0Q7U0FDekQ7SUFDTCxDQUFDO0lBRU8sNkNBQVcsR0FBbkIsVUFBb0IsTUFBTTtRQUN0QixJQUFJLE1BQU0sS0FBSyxTQUFTLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtZQUN6QyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDdkM7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBL0N1QjtRQUF2QixLQUFLLENBQUMsZUFBZSxDQUFDOztrRUFBb0I7SUFDM0I7UUFBZixLQUFLLENBQUMsT0FBTyxDQUFDOzswREFBc0I7SUFDYjtRQUF2QixLQUFLLENBQUMsZUFBZSxDQUFDOztrRUFBZTtJQUNmO1FBQXRCLEtBQUssQ0FBQyxjQUFjLENBQUM7O2lFQUFjO0lBQ3BCO1FBQWYsS0FBSyxDQUFDLE9BQU8sQ0FBQzs7MERBQWdCO0lBQ3JCO1FBQVQsTUFBTSxFQUFFOztnRUFBa0M7SUFDakM7UUFBVCxNQUFNLEVBQUU7O2dFQUFrQztJQVJsQyx1QkFBdUI7UUFMbkMsU0FBUyxDQUFDO1lBQ1AsUUFBUSxFQUFFLGlCQUFpQjtZQUMzQiw0bEJBQThDO1NBQ2pELENBQUM7T0FFVyx1QkFBdUIsQ0FrRG5DO0lBQUQsOEJBQUM7Q0FBQSxBQWxERCxJQWtEQztTQWxEWSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgeyBNYXRTbmFja0JhciB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMsIElucHV0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbi10b2dnbGVvcHRpb25zJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbi10b2dnbGVvcHRpb25zLnRlbXBsYXRlLmh0bWwnXG59KVxuXG5leHBvcnQgY2xhc3MgTlRvZ2dsZW9wdGlvbnNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gICAgLy8gb3B0aW9ucyA9IHtpY29uOiAnaG9tZScsIHZhbHVlOiAnaG9tZScsIGRpc2FibGVkOiBmYWxzZSwgJ2NoZWNrZWQnOiBmYWxzZX1cbiAgICBASW5wdXQoJ3RvZ2dsZU9wdGlvbnMnKSB0b2dnbGVPcHRpb25zID0gW107XG4gICAgQElucHV0KCdhbGlnbicpIGFsaWduID0gJ2hvcml6b250YWwnO1xuICAgIEBJbnB1dCgnZGlzYWJsZWRJbmRleCcpIGRpc2FibGVkSW5kZXg7XG4gICAgQElucHV0KCdjaGVja2VkSW5kZXgnKSBjaGVja2VkSW5kZXg7XG4gICAgQElucHV0KCd2YWx1ZScpIHZhbHVlIDogc3RyaW5nO1xuICAgIEBPdXRwdXQoKSBpbmRleENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLy8gY29uc3RydWN0b3IocHJpdmF0ZSBzbmFja2JhcjogTWF0U25hY2tCYXIpIHtcbiAgICAvLyB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tOdW1iZXIodGhpcy5jaGVja2VkSW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrZWRJbmRleCA9IE51bWJlcih0aGlzLmNoZWNrZWRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jaGVja051bWJlcih0aGlzLmRpc2FibGVkSW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkSW5kZXggPSBOdW1iZXIodGhpcy5kaXNhYmxlZEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snY2hlY2tlZEluZGV4J10gJiYgdGhpcy5jaGVja051bWJlcih0aGlzLmNoZWNrZWRJbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZEluZGV4ID0gTnVtYmVyKHRoaXMuY2hlY2tlZEluZGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2VzWydkaXNhYmxlZEluZGV4J10gJiYgdGhpcy5jaGVja051bWJlcih0aGlzLmRpc2FibGVkSW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkSW5kZXggPSBOdW1iZXIodGhpcy5kaXNhYmxlZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbkNsaWNrZWQoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9nZ2xlT3B0aW9ucyAmJiB0aGlzLnRvZ2dsZU9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleENoYW5nZS5lbWl0KGluZGV4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZU9wdGlvbnNbaW5kZXhdICYmIHRoaXMudG9nZ2xlT3B0aW9uc1tpbmRleF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy50b2dnbGVPcHRpb25zW2luZGV4XS52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuc25hY2tiYXIub3BlbignSW52YWxpZCB0b2dnbGUgYnV0dG9uIHZhbHVlJywgJ09LJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzLnNuYWNrYmFyLm9wZW4oJ0ludmFsaWQgdG9nZ2xlIG9wdGlvbnMnLCAnT0snKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2hlY2tOdW1iZXIobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgIT09IHVuZGVmaW5lZCAmJiBudW1iZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oTnVtYmVyKG51bWJlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXX0=